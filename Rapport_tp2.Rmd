---
output: pdf_document
---
\newpage
\begin{flushright}
    Équipe 04 
\end{flushright}

\begin{center}
    \vspace{5\baselineskip}
    Nicholas Langevin \\
    (111 184 631) \\
    \vspace{2\baselineskip}
    Alexandre Turcotte \\
    (111 172 613) \\
    \vspace{8\baselineskip}
    Mathématiques actuarielles IARD 1 \\
    ACT-2005 \\
    \vspace{8\baselineskip}
    \textbf{Travail pratique 2} \\
    \vspace{8\baselineskip}
    Travail présenté à \\
    Andrew Luong \\
    \vspace{8\baselineskip}
    École d’actuariat \\
    Université Laval \\
    Automne 2018
\end{center}

\newpage
# Question 1
## Méthode de vraisemblance avec données complètes
### a) Estimation des paramètres

Le jeu de données utilisé afin de compléter ce numéro comportait les 10 données suivantes :
\vspace{1\baselineskip}
\begin{center}
 1500 \ 6000 \ 3500 \ 3800 \ 1800 \ 5500 \ 4800 \ 4200 \ 3900 \ 3000
\end{center}
\vspace{1\baselineskip}
À partir de ces données et de SAS, il a été possible d'estimer les paramètres $\hat{\mu}$ et $\hat{\sigma}$ d'une loi log-normale à partir de la méthode du maximum de vraisemblance. D'ailleurs, le code SAS se trouve dans l'Annexe à la fin du rapport. Voici, les estimés des paramètres obtenus: 

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Les données
data <-  c(1500, 6000, 3500, 3800, 1800, 5500, 4800, 4200, 3900, 3000)

# Les estimateurs ont été calculés à l'aide de SAS
Estimateurs <- data.frame("mu" =8.1618, "sigma" = 0.4278)

# Présenter les estimateurs dans un tableau
#library(xtable)
#options(xtable.comment = FALSE)
#xtable(Estimateurs, caption = "Paramètres estimés d'une loi log-normale à l'aide du maximum de vraisemblance",  
#                 align = c("c", "c", "c"),
#                 digits = c(0, 4, 4)) 
```
\begin{table}[ht]
\centering
\begin{tabular}{cc}
  \hline
  \bf $\bf{\hat{\mu}}$ & \bf $\hat{\sigma}$ \\ 
  \hline
  8.1618 & 0.4278 \\ 
  \hline
\end{tabular}
\caption{Paramètres estimés d'une loi log-normale à l'aide du maximum de vraisemblance}
\end{table}

\vspace{1\baselineskip}
Il est également possible de déterminer les estimateurs de façon théorique. D'abord, il faut déterminer la fonction $g(x_i;\mu, \sigma)$ pour les dix scénarios, et ce, en fonction de la densité de X.
\vspace{1\baselineskip}

Alors comme $X \sim LN(\mu, \sigma)$, la densité de f(x) est la suivante :
\begin{align*}
    f_x(x) = \frac{1}{\sqrt{2\pi}x\sigma}e^{\frac{-1}{2} \left(\frac{In(x)-\mu}{\sigma} \right)^2}  \\
\end{align*}

Ensuite, il faut appliquer la vraisemblance en tenant compte des 10 scénarios et de la densité de X.
\begin{align*}
    \L(\mu, \sigma) 
    &= \prod_{i=1}^{10}g(x_i;\mu,\sigma) \\
    \\
    &= f_x(1500) \cdot f_x(6000) \cdot ... \cdot f_x(3000) \\
    \\
    &= \left[ \frac{1}{\sqrt{2\pi}1500\sigma}e^{\frac{-1}{2}(\frac{In(1500)-\mu}{\sigma})^2} \right] \cdot \left[         \frac{1}{\sqrt{2\pi}6000\sigma}e^{\frac{-1}{2}(\frac{In(6000)-\mu}{\sigma})^2} \right] \cdot ... \cdot \left[         \frac{1}{\sqrt{2\pi}3000\sigma}e^{\frac{-1}{2}(\frac{In(3000)-\mu}{\sigma})^2} \right] \\
    \\
    &= \left(\frac{1}{2\pi} \right)^5 \left(\frac{1}{\sigma} \right)^{10} \left(\frac{1}{2.795153962 \times 10^{35}} \right) e^{\frac{-1}{2\sigma^2} \left[(In(1500) - \mu)^2 + (In(6000) - \mu)^2 + ... + (In(3000) - \mu)^2 \right]} \\
\end{align*}

\newpage
Par la suite, il faut appliquer la log vraisemblance.
\begin{align*}
    \l(\mu, \sigma) 
    &= In(L(\mu, \sigma)) = In \prod_{i=1}^{10}g(x_i; \mu, \sigma) \\
    &= -5In(2\pi) - 10In(\sigma) - In(2.795153962 \times 10^{35}) \\ 
    &- \frac{1}{2\sigma^2} \left[(In(1500) - \mu)^2 + (In(6000) - \mu)^2 + ... + (In(3000) - \mu)^2 \right] \\
\end{align*}

Finalement, il faut dériver la log vraisemblance selon les deux paramètres et égaliser les deux équations à 0 pour pouvoir estimer les paramètres en les isolant.

Dériver selon $\mu$
\begin{align*}
    \frac{d}{d\mu}l(\mu, \sigma) 
    &= \frac{-1}{2\sigma^2} \left[-2(In(1500) - \mu) -2(In(6000) - \mu) - ... -2(In(3000) - \mu) \right] \\
    \ 0 
    &= \frac{1}{\hat{\sigma}^2} \left[In(1500) + In(6000) + ... + In(3000) - 10\hat{\mu} \right] \\
    \ \hat{\mu}
    &= \frac{1}{10}\sum_{i=1}^{10} In(x_i) \ = \ 8.161836544 \\
\end{align*}

Dériver selon $\sigma$
\begin{align*}
    \frac{d}{d\sigma}l(\mu, \sigma) 
    &= \frac{-10}{\sigma} + \frac{1}{\sigma^3} \sum_{i=1}^{10} (In(x_i) - \mu)^2 \\
    \ 0
    &= \frac{-10}{\hat{\sigma}} + \frac{1}{\hat{\sigma}^3} \sum_{i=1}^{10} (In(x_i) - \hat{\mu})^2 \\
    \ \hat{\sigma}^2
    &= \frac{1}{10}\sum_{i=1}^{10} (In(x_i) - 8.161836544)^2 \ = \ 0.1830137502 \\
    \ \hat{\sigma}
    &= \sqrt{\hat{\sigma}^2} \ = \ 0.427801064\\
\end{align*}

Donc, les estimateurs de la loi log-normale, selon la méthode du maximum de vraisemblance, sont $\hat{\mu}$ = `r Estimateurs[1]` et $\hat{\sigma}$ = `r Estimateurs[2]`.



\newpage
### b) Détermination des primes stop-loss
En ayant obtenu les estimés des paramètres à la question a), il est maintenant possible d'effectuer divers calculs puisque la distribution du modèle est maintenant connue. Par conséquent, il est possible de calculer la prime stop-loss $E[(X-d)_+]$, et ce, pour différentes valeurs de déductible, soit d = 2000, 2100, ..., 3000. Pour y arriver, il faut utiliser la formule suivante:

\begin{align*}
    \ E \left[ (X-d)_{+} \right] 
    &= e^{\hat{\mu}+\frac{\hat{\sigma}^2}{2}} \left(1 - \Phi \left(\frac{Ind - \hat{\mu} - \hat{\sigma}^2}{\hat{\sigma}} \right) \right) - d \left(1 - \Phi \left(\frac{Ind - \hat{\mu}}{\hat{\sigma}} \right) \right)\\
\end{align*}

où $\hat{\mu}$ = `r Estimateurs[1]`, $\hat{\sigma}$ = `r Estimateurs[2]` et d = déductible. Par conséquent, les valeurs obtenues pour la prime stop-loss sont les suivantes:

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Les estimateurs ont été calculés à l'aide de SAS en a)
mu <- 8.1618
sigma <-  0.4278

# Valeurs des déductibles d à utiliser
d <- 100 * seq(20,30)

# Calculer les primes STOP-LOSS pour les différents déductibles d
STOP_LOSS <- function(x) {
    exp(mu + sigma^2/2) * (1 - pnorm((log(x) - mu - sigma^2)/sigma)) - 
        x * (1 - pnorm((log(x) - mu)/sigma))
}

Primes_STOP_LOSS <- data.frame(d, "Prime" = sapply(d, function(x) STOP_LOSS(x)))

# Présenter les valeurs des primes STOP-LOSS en fonction de d 
#library(xtable)
#options(xtable.comment = FALSE)
#xtable(Primes_STOP_LOSS, caption = "Valeurs de la prime STOP-LOSS pour chacun des déductibles d donnés",  
#                 align = c("c", "c", "c"),
#                 digits = c(0, 0, 4)) 
```
\begin{table}[ht]
\centering
\begin{tabular}{cc}
  \hline
 \bf{d} & \bf{Prime stop-loss} \\ 
  \hline
  2000 & 1872.5736 \\ 
  2100 & 1783.0847 \\ 
  2200 & 1695.7633 \\ 
  2300 & 1610.7845 \\ 
  2400 & 1528.3012 \\ 
  2500 & 1448.4425 \\ 
  2600 & 1371.3131 \\ 
  2700 & 1296.9934 \\ 
  2800 & 1225.5400 \\ 
  2900 & 1156.9871 \\ 
  3000 & 1091.3484 \\ 
   \hline
\end{tabular}
\caption{Valeurs de la prime stop-loss pour chacun des déductibles d donnés} 
\end{table}

À partir des valeurs de la $\it{Table \ 2}$, il est possible d'observer une baisse du niveau de la prime lorsque le déductible augmente. De plus, en regardant le graphique (A) de la $\it{Figure \ 1}$, il est possible d'observer cette décroissance qui semble à première vue assez linéaire. Toutefois, en regardant le graphique (B) de la $\it{Figure \ 1}$, ayant un plus grand nombre de valeurs de d, on remarque la convexité de la courbe, ce qui signifie que plus d augmente, moins la diminution est significative. Par exemple, l'écart entre 2000 et 2100 est plus important que l'écart entre 2900 et 3000. Bref, cela fait du sens puisqu'en ajoutant un déductible, la compagnie vient diminuer le risque ainsi que le montant de prestation qu'elle devra verser. Par conséquent, le niveau de la prime devrait diminuer, et ce, avec un impact de moins en moins significatif, car la valeur ajoutée d'augmenter le déductible pour la compagnie est de moins en moins importante.

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Représenter graphiquement l'évalution en fonction de d
library(ggplot2)
plot1 <- ggplot(data = Primes_STOP_LOSS, aes(x= Primes_STOP_LOSS$d, y = Primes_STOP_LOSS$Prime)) + geom_point() + geom_line() + xlab("d") + ylab("Prime stop-loss") +ggtitle("(A)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

value_test <- data.frame(d=(100 * seq(20,60)), "Prime" = sapply((100 * seq(20,60)), function(x) STOP_LOSS(x)))

plot2 <- ggplot(data=value_test, aes(x=value_test$d, y=value_test$Prime)) + geom_point() + geom_line() + xlab("d") + ylab("Prime stop-loss") +ggtitle("(B)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))
```



### c) Détermination de l'espérance limitée
Maintenant, toujours en utilisant les paramètres estimés en a), il faut désormais calculer l'espérance limitée, sans déductible, et ce, pour différentes limites supérieures, soit u = 3000, 3100, ..., 4000. Pour y arriver, il faut utiliser la formule suivante:

\begin{align*}
    \ E \left[X \Lambda u \right] 
    &= e^{\hat{\mu}+\frac{\hat{\sigma}^2}{2}} \Phi \left(\frac{In(u) - \hat{\mu} - \hat{\sigma}^2}{\hat{\sigma}} \right) + u \left(1 - \Phi \left(\frac{In(u) - \hat{\mu}}{\hat{\sigma}} \right) \right)\\
\end{align*}

où $\hat{\mu}$ = `r Estimateurs[1]`, $\hat{\sigma}$ = `r Estimateurs[2]` et u = limite. Par conséquent, les valeurs obtenues pour l'espérance limitée sont les suivantes:

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Valeurs des limites u à utiliser
u <- 100 * seq(30,40)

# Calculer l'espérance limitée pour les différents limites u
Esp_limite <- function(x) {
    exp(mu + sigma^2/2) * pnorm((log(x) - mu - sigma^2)/sigma) + 
        x * (1 - pnorm((log(x) - mu)/sigma))
}

Primes_Esp_limite <- data.frame(u, "Prime" = sapply(u, function(x) Esp_limite(x)))

# Présenter les valeurs des espérances limitées en fonction de u
#library(xtable)
#options(xtable.comment = FALSE)
#xtable(Primes_Esp_limite, caption = "Valeurs de l'espérance limitée pour chacune des limites u données",  
#                 align = c("c", "c", "c"),
#                 digits = c(0, 0, 4)) 
```
\begin{table}[ht]
\centering
\begin{tabular}{cc}
  \hline
 \bf{u} & \bf{Espérance limitée} \\ 
  \hline
  3000 & 2748.9541 \\ 
  3100 & 2811.6843 \\ 
  3200 & 2871.5287 \\ 
  3300 & 2928.5251 \\ 
  3400 & 2982.7242 \\ 
  3500 & 3034.1882 \\ 
  3600 & 3082.9884 \\ 
  3700 & 3129.2039 \\ 
  3800 & 3172.9195 \\ 
  3900 & 3214.2249 \\ 
  4000 & 3253.2129 \\ 
   \hline
\end{tabular}
\caption{Valeurs de l'espérance limitée pour chacune des limites u données} 
\end{table}

À partir des valeurs de la $\it{Table \ 3}$, il est possible d'observer une hausse du niveau de la prime lorsque la limite augmente. De plus, en regardant le graphique (C) de la $\it{Figure \ 1}$, il est possible d'observer cette croissance. D'ailleurs, en regardant le graphique (D) de la $\it{Figure \ 1}$, ayant un plus grand nombre de valeurs u, on remarque la concavité de la courbe, ce qui signifie que plus u augmente, moins l'augmentation est significative. Bref, cela fait du sens puisqu'en ayant une limite plus faible, la compagnie vient diminuer le risque ainsi que le montant de prestation qu'elle devra verser puisqu'elle ne payera pas ce qui a en excédent. Par conséquent, le niveau de la prime va augmenter plus la limite est grande, car la compagnie devra débourser de plus grandes sommes, et ce, avec un impact de moins en moins significatif, car, à un certain point, le fait d'augmenter la limite va affecter peu de gens, donc la hausse des sommes à débourser sera moins importante.

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Représenter graphiquement l'évalution en fonction de d
library(ggplot2)
plot3 <- ggplot(data = Primes_Esp_limite, aes(x= Primes_Esp_limite$u, y = Primes_Esp_limite$Prime)) + geom_point() + geom_line() + xlab("u") + ylab("Espérance limitée") +ggtitle("(C)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

value_test_2 <- data.frame(u=(100 * seq(30,60)), "Prime" = sapply((100 * seq(30,60)), function(x) Esp_limite(x)))

plot4 <- ggplot(data=value_test_2, aes(x=value_test_2$u, y=value_test_2$Prime)) + geom_point() + geom_line() + xlab("u") + ylab(" Espérance limitée") +ggtitle("(D)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))


library(gridExtra)
grid.arrange(plot1, plot2, plot3, plot4, ncol=2, nrow=2)
```
\begin{center}
 Figure 1 : (A) et (B) Représentation graphique de la prime stop-loss en fonction de d. (C) et (D) Représentation graphique de l'espérance limitée en fonction de u. Toutefois, l'étendu des valeurs sur l'axe des abscisses est plus importante pour les graphiques (B) et (D) afin de mieux discerner la tendance.
\end{center}


### d) Détermination de la prime stop-loss par simulation avec un déductible de 2000
Il est également possible d'approximer la prime stop-loss par simulation. Alors, il est possible de tirer un échantillon de la loi log-normale suffisament grand pour estimer la prime stop-loss. Cela a été fait avec un m = 100 000, 500 000 et 1 000 000. Pour y arriver, il faut utiliser la formule suivante:

\begin{align*}
    \ E \left[ (X-2000)_{+} \right] 
    &= \frac{1}{m}\sum_{i=1}^{m} max(0, X-2000) \\
\end{align*}

Par conséquent, les valeurs obtenues pour la prime stop-loss sont les suivantes:
```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Valeurs du déductible d à utiliser
d <- 2000

# Nombre de simulations
m <- c(1e5, 5e5, 1e6)

# Simuler un échantillon de m simulations de la log log-normale
# avec les paramètres estimés en a)
simul <- function(x) rlnorm(x, meanlog = mu, sdlog = sigma)
simulation <- sapply(1:3, function(i) simul(m[i]))

# Approximer la prime STOP-LOSS ayant un déductible de 2000 par simulation
approximation <- sapply(1:3, function(x)
                    mean(sapply(1:m[x], function(i) 
                        max(0, simulation[[x]][i] - 2000))))

approx <- data.frame(m, approximation)

# Écarts relatifs
Prime_2000 <- Primes_STOP_LOSS$Prime[1]
#Approx <- approx$approximation
Approx <- c(1870.0455, 1872.1354, 1872.3536)
Ecart <- abs((Approx-Prime_2000)/Prime_2000) * 100

# Présenter les valeurs approximées de la prime STOP-LOSS ayant un déductible de 2000 
#library(xtable)
#options(xtable.comment = FALSE)
#xtable(approx, caption = "Valeurs approximées par simulations de la prime STOP-LOSS ayant un déductible de 2000",  
#                 align = c("c", "c", "c"),
#                 digits = c(0, 0, 4)) 
```
\begin{table}[ht]
\centering
\begin{tabular}{cc}
  \hline
 \bf{m} & \bf{approximation} \\ 
  \hline
  100000 & 1870.0455 \\ 
  500000 & 1872.1354 \\ 
  1000000 & 1872.3536 \\ 
   \hline
\end{tabular}
\caption{Valeurs approximées par simulations de la prime stop-loss ayant un déductible de 2000} 
\end{table}

La valeur de la prime stop-loss calculée en b) pour un déductible de 2000 est de `r round(Prime_2000,4)`. Puis, en regardant les résultats obtenus à l'aide de la simulation, on se rend compte que ceux-ci sont très près de la valeur théorique, soit `r round(Approx[1],4)`, `r round(Approx[2],4)` et `r round(Approx[3],4)` pour 100 000, 500 000 et 1 000 000 simulations respectivement. En effet, les écarts relatifs sont de `r round(Ecart[1],4)`%, `r round(Ecart[2],4)`% et `r round(Ecart[3],4)`%. Par conséquent, l'approximation est très précise et donne sensiblement la même valeur que la valeur théorique lorsqu'un grand nombre de simulations est effectué.

\newpage
# Question 2
## Méthode de vraisemblance avec données groupées
### a) Estimation des paramètres

Le jeu de données utilisé afin de compléter ce numéro comportait les données suivantes :
\begin{table}[ht]
\centering
\begin{tabular}{cc}
  \hline
 \bf{Intervalles} & \bf{nombres} \\ 
  \hline
  0-250 & 3 \\ 
  250-500 & 4 \\ 
  500-750 & 5 \\
  750-1000 & 5 \\ 
  1000-1250 & 4 \\ 
  1250-1500 & 3 \\ 
  1500-2000 & 3 \\
  2000-2500 & 3 \\
  2500-3000 & 2 \\
  3000-5000 & 2 \\
  \hline
\end{tabular}
\caption{Jeux de données de la question 2} 
\end{table}
À partir de ces données et de SAS, il a été possible d'estimer les paramètres $\hat{\mu}$ et $\hat{\sigma}$ d'une loi log-normale à partir de la méthode du maximum de vraisemblance. D'ailleurs, le code SAS se trouve dans l'Annexe à la fin du rapport. Voici, les estimés des paramètres obtenus: 

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Les estimateurs ont été calculés à l'aide de SAS
Estimateurs_2 <- data.frame("mu" =6.8418, "sigma" = 0.8278)

# Présenter les estimateurs dans un tableau
#library(xtable)
#options(xtable.comment = FALSE)
#xtable(Estimateurs_2, caption = "Paramètres estimés d'une loi log-normale à l'aide du maximum de vraisemblance",  
#                 align = c("c", "c", "c"),
#                 digits = c(0, 4, 4)) 
```
\begin{table}[ht]
\centering
\begin{tabular}{cc}
  \hline
 $\hat{\mu}$ & $\hat{\sigma}$ \\ 
  \hline
  6.8418 & 0.8278 \\ 
  \hline
\end{tabular}
\caption{Paramètres estimés d'une loi log-normale à l'aide du maximum de vraisemblance} 
\end{table}


\vspace{1\baselineskip}
Afin de déterminer les estimateurs de la loi log-normale, il faut d'abord trouver la fonction $g(x_i;\mu, \sigma)$ pour l'ensemble des scénarios, et ce, en fonction de la répartition de X puisque les valeurs correspondent à un interval et non à une valeur ponctuelle.
\vspace{1\baselineskip}

Alors comme $X \sim LN(\mu, \sigma)$, la fonction de répartition F(x) est la suivante :
\begin{align*}
    F_x(x) = \Phi \left(\frac{In(x) - \mu}{\sigma} \right)\\
\end{align*}

Ensuite, il faut appliquer la vraisemblance en tenant compte de tous les scénarios possibles et de la répartition de X.
\begin{align*}
    \L(\mu, \sigma) 
    &= \prod_{i=1}^{10}g(x_i;\mu,\sigma) \\
    &= [F_x(250) - F_x(0)]^3 \cdot [F_x(500) - F_x(250)]^4 \cdot ...  \cdot [F_x(5000) - F_x(3000)]^2  \\
\end{align*}
\begin{align*}
    &= \left [\Phi \left(\frac{In(250) - \mu}{\sigma} \right) - \Phi \left(\frac{In(0) - \mu}{\sigma} \right) \right]^3 \cdot \left [\Phi \left(\frac{In(500) - \mu}{\sigma} \right) - \Phi \left(\frac{In(250) - \mu}{\sigma} \right) \right]^4  \\
    &\cdot ... \cdot  \left [\Phi \left(\frac{In(5000) - \mu}{\sigma} \right) - \Phi \left(\frac{In(3000) - \mu}{\sigma} \right) \right]^2 \\
\end{align*}

Par la suite, il faut appliquer la log vraisemblance.
\begin{align*}
    \l(\mu, \sigma) 
    &= In(L(\mu, \sigma)) = In \prod_{i=1}^{10}g(x_i; \mu, \sigma) \\
    &= 3 In \left[\Phi \left(\frac{In(250) - \mu}{\sigma} \right) - 0 \right] + 4 In \left[\Phi \left(\frac{In(500) - \mu}{\sigma} \right) -  \Phi \left(\frac{In(250) - \mu}{\sigma} \right) \right]  \\ 
    &+...+ 2 In \left[\Phi \left(\frac{In(5000) - \mu}{\sigma} \right) -  \Phi \left(\frac{In(3000) - \mu}{\sigma} \right) \right] \\
\end{align*}

Finalement, il faut chercher à maximiser la fonction log vraisemblance afin d'obtenir les estimateurs $\hat{\mu}$ et $\hat{\sigma}$. Cela a été fait à l'aide du logiciel SAS.

Donc, les estimateurs de la loi log-normale, selon la méthode du maximum de vraisemblance, sont $\hat{\mu}$ = `r Estimateurs_2[1]` et $\hat{\sigma}$ = `r Estimateurs_2[2]`.


### b) Détermination des primes stop-loss
En ayant obtenu les estimés des paramètres à la question a), il est maintenant possible d'effectuer divers calculs puisque la distribution du modèle est maintenant connue. Par conséquent, il est possible de calculer la prime stop-loss $E[(X-d)_+]$, et ce, pour différentes valeurs de déductible, soit d = 2000, 2100, ..., 3000. Pour y arriver, il faut utiliser la formule suivante:

\begin{align*}
    \ E \left[ (X-d)_{+} \right] 
    &= e^{\hat{\mu}+\frac{\hat{\sigma}^2}{2}} \left(1 - \Phi \left(\frac{Ind - \hat{\mu} - \hat{\sigma}^2}{\hat{\sigma}} \right) \right) - d \left(1 - \Phi \left(\frac{Ind - \hat{\mu}}{\hat{\sigma}} \right) \right)\\
\end{align*}

où $\hat{\mu}$ = `r Estimateurs_2[1]`, $\hat{\sigma}$ = `r Estimateurs_2[2]` et d = déductible. Par conséquent, les valeurs obtenues pour la prime stop-loss sont les suivantes:

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Les estimateurs ont été calculés à l'aide de SAS en a)
mu_2 <- 6.8418
sigma_2 <-  0.8278

# Valeurs des déductibles d à utiliser
d_2 <- 100 * seq(20,30)

# Calculer les primes STOP-LOSS pour les différents déductibles d
STOP_LOSS_2 <- function(x) {
    exp(mu_2 + sigma_2^2/2) * (1 - pnorm((log(x) - mu_2 - sigma_2^2)/sigma_2)) - 
        x * (1 - pnorm((log(x) - mu_2)/sigma_2))
}

Primes_STOP_LOSS_2 <- data.frame(d_2, "Prime" = sapply(d_2, function(x) STOP_LOSS_2(x)))

# Présenter les valeurs des primes STOP-LOSS en fonction de d 
#library(xtable)
#options(xtable.comment = FALSE)
#xtable(Primes_STOP_LOSS_2, caption = "Valeurs de la prime STOP-LOSS pour chacun des déductibles d donnés",  
#                 align = c("c", "c", "c"),
#                 digits = c(0, 0, 4)) 
```
\begin{table}[ht]
\centering
\begin{tabular}{cc}
  \hline
 \bf{d} & \bf{Prime stop-loss} \\ 
  \hline
  2000 & 253.3579 \\ 
  2100 & 236.1653 \\ 
  2200 & 220.3997 \\ 
  2300 & 205.9213 \\ 
  2400 & 192.6061 \\ 
  2500 & 180.3436 \\ 
  2600 & 169.0355 \\ 
  2700 & 158.5939 \\ 
  2800 & 148.9402 \\ 
  2900 & 140.0041 \\ 
  3000 & 131.7223 \\ 
   \hline
\end{tabular}
\caption{Valeurs de la prime stop-loss pour chacun des déductibles d donnés} 
\end{table}

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Représenter graphiquement l'évolution en fonction de d
library(ggplot2)
plot5 <- ggplot(data = Primes_STOP_LOSS_2, aes(x= Primes_STOP_LOSS_2$d_2, y = Primes_STOP_LOSS_2$Prime)) + geom_point() + geom_line() + xlab("d") + ylab("Prime stop-loss") +ggtitle("(A)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

value_test_3 <- data.frame(d=(100 * seq(20,60)), "Prime" = sapply((100 * seq(20,60)), function(x) STOP_LOSS_2(x)))

plot6 <- ggplot(data=value_test_3, aes(x=value_test_3$d, y=value_test_3$Prime)) + geom_point() + geom_line() + xlab("d") + ylab("Prime stop-loss") +ggtitle("(B)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))
```

À partir des valeurs de la $\it{Table \ 7}$, il est possible d'observer une baisse du niveau de la prime lorsque le déductible augmente. De plus, en regardant le graphique (A) de la $\it{Figure \ 2}$, il est possible d'observer cette décroissance qui semble à première vue assez linéaire. Toutefois, en regardant le graphique (B) de la $\it{Figure \ 2}$, ayant un plus grand nombre de valeurs de d, on remarque la convexité de la courbe, ce qui signifie que plus d augmente, moins la diminution est significative. Bref, cela fait du sens puisqu'en ajoutant un déductible, la compagnie vient diminuer le montant qu'elle devra verser en prestations. Par conséquent, le niveau de la prime devrait diminuer, et ce, avec un impact de moins en moins significatif, car la valeur ajoutée d'augmenter le déductible pour la compagnie est de moins en moins importante.

\newpage
### c) Détermination de l'espérance limitée
Maintenant, toujours en utilisant les paramètres estimés en a), il faut désormais calculer l'espérance limitée, sans déductible, et ce, pour différentes limites supérieure, soit u = 3000, 3100, ..., 4000. Pour y arriver, il faut utiliser la formule suivante:

\begin{align*}
    \ E \left[X \Lambda u \right] 
    &= e^{\hat{\mu}+\frac{\hat{\sigma}^2}{2}} \Phi \left(\frac{Inu - \hat{\mu} - \hat{\sigma}^2}{\hat{\sigma}} \right) + u \left(1 - \Phi \left(\frac{Inu - \hat{\mu}}{\hat{\sigma}} \right) \right)\\
\end{align*}

où $\hat{\mu}$ = `r Estimateurs_2[1]`, $\hat{\sigma}$ = `r Estimateurs_2[2]` et u = limite. Par conséquent, les valeurs obtenues pour l'espérance limitée sont les suivantes:

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Valeurs des limites u à utiliser
u_2 <- 100 * seq(30,40)

# Calculer l'espérance limitée pour les différents limites u
Esp_limite_2 <- function(x) {
    exp(mu_2 + sigma_2^2/2) * pnorm((log(x) - mu_2 - sigma_2^2)/sigma_2) + 
        x * (1 - pnorm((log(x) - mu_2)/sigma_2))
}

Primes_Esp_limite_2 <- data.frame(u_2, "Prime" = sapply(u_2, function(x) Esp_limite_2(x)))

# Présenter les valeurs des espérances limitées en fonction de u
#library(xtable)
#options(xtable.comment = FALSE)
#xtable(Primes_Esp_limite_2, caption = "Valeurs de l'espérance limitée pour chacune des limites u données",  
#                 align = c("c", "c", "c"),
#                 digits = c(0, 0, 4)) 
```
\begin{table}[ht]
\centering
\begin{tabular}{cc}
  \hline
 \bf{u} & \bf{Espérance limitée} \\ 
  \hline
  3000 & 1187.0103 \\ 
  3100 & 1194.6945 \\ 
  3200 & 1201.8320 \\ 
  3300 & 1208.4691 \\ 
  3400 & 1214.6471 \\ 
  3500 & 1220.4038 \\ 
  3600 & 1225.7731 \\ 
  3700 & 1230.7858 \\ 
  3800 & 1235.4700 \\ 
  3900 & 1239.8511 \\ 
  4000 & 1243.9524 \\ 
   \hline
\end{tabular}
\caption{Valeurs de l'espérance limitée pour chacune des limites u données} 
\end{table}

À partir des valeurs de la $\it{Table \ 8}$, il est possible d'observer une hausse du niveau de la prime lorsque la limite augmente. De plus, en regardant le graphique (C) de la $\it{Figure \ 2}$, il est possible d'observer cette croissance. D'ailleurs, en regardant le graphique (D) de la $\it{Figure \ 2}$, ayant un plus grand nombre de valeurs u, on remarque la concavité de la courbe, ce qui signifie que plus u augmente, moins l'augmentation est significative. Bref, cela fait du sens puisqu'en ayant une limite plus faible, la compagnie vient diminuer le risque ainsi que le montant de prestation qu'elle devra verser puisqu'elle ne payera pas ce qui a en excédent. Par conséquent, le niveau de la prime va augmenter plus la limite est grande, car la compagnie devra débourser de plus grandes sommes, et ce, avec un impact de moins en moins significatif, car, à un certain point, le fait d'augmenter la limite va affecter peu de gens, donc la hausse des sommes à débourser sera moins importante.

```{R, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
# Représenter graphiquement l'évalution en fonction de d
library(ggplot2)
plot7 <- ggplot(data = Primes_Esp_limite_2, aes(x= Primes_Esp_limite_2$u_2, y = Primes_Esp_limite_2$Prime)) + geom_point() + geom_line() + xlab("u") + ylab("Espérance limitée") +ggtitle("(C)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

value_test_4 <- data.frame(u=(100 * seq(30,60)), "Prime" = sapply((100 * seq(30,60)), function(x) Esp_limite_2(x)))

plot8 <- ggplot(data=value_test_4, aes(x=value_test_4$u, y=value_test_4$Prime)) + geom_point() + geom_line() + xlab("u") + ylab(" Espérance limitée") +ggtitle("(D)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))


library(gridExtra)
grid.arrange(plot5, plot6, plot7, plot8, ncol=2, nrow=2)
```
\begin{center}
 Figure 2 : (A) et (B) Représentation graphique de la prime stop-loss en fonction de d. (C) et (D) Représentation graphique de l'espérance limitée en fonction de u. Toutefois, l'étendu des valeurs sur l'axe des abscisses est plus importante pour les graphiques (B) et (D) afin de mieux discerner la tendance.
\end{center}




\newpage
# Question 3
## Estimateur de Bayes
### a) Estimation du paramètre $\theta$
On trouve le maximum de vraisemblance pour la loi binomiale négative avec $r = 2$ et le paramètre $\theta$, qui représente la probabilité de succès. On suposse de prime à bord qu'il n'y a pas de loi à priori. Le maximum de vraisemblance est alors
défini par:
\begin{align*}
L(\theta) &= \prod_{i=1}^n \binom{r + x_1 -1}{x_i} \theta^r (1 - \theta)^{x_i} \\
&= \theta^{nr} (1 - \theta)^{\sum_{i=1}^n x_i} \prod_{i=1}^n \binom{r + x_1 -1}{x_i} 
\end{align*}
On trouve alors la log-vraisemblance
\begin{align*}
l(\theta) &= \ln(\theta^{nr}) + \ln(1 - \theta)^{\sum_{i=1}^n x_i} - \sum_{i=1}^n \ln\binom{r + x_1 -1}{x_i} \\
&= nr \ln\theta + \sum_{i=1}^n x_i \ln(1 - \theta) - \sum_{i=1}^n \ln\binom{r + x_1 -1}{x_i}
\end{align*}
On dérive ensuite par rapport à $\theta$ pour trouver l'estimateur
\begin{align*}
\frac{dl(\theta)}{d\theta} &= \frac{nr}{\theta} - \frac{\sum_{i=1}^n x_i}{(1-\theta)} = 0 \\
\Rightarrow& \frac{nr}{\hat{\theta}} = \frac{\sum_{i=1}^n x_i}{(1-\hat{\theta})} \\
\Rightarrow& \frac{nr(1-\hat{\theta})}{\hat{\theta}} = \sum_{i=1}^n x_i \\
\Rightarrow& \frac{nr}{\hat{\theta}} =  \sum_{i=1}^n x_i + nr \\
\Rightarrow& \hat{\theta}_{MLE} = \frac{nr}{\sum_{i=1}^n x_i + nr} \\
\Rightarrow& \hat{\theta}_{MLE} = \frac{r}{\bar{x} + r} \\
\end{align*}
On calcule ensuite le maximum de vraisemblance avec notre unique donnée $x = 5$
\[ \hat{\theta}_{MLE} = \frac{r}{\bar{x} + r} = \frac{2}{5 + 2} = \frac{2}{7} \]


### b) Présentation graphique de la loi beta a priori
On choisit comme loi à priori la loi beta avec $\alpha = 2$ et $\beta = 2$. On prend la loi beta puisque son domaine respecte le domaine de notre estimateur, soit $\theta \in [0, 1]$. La $\it{Figure \ 3}$ permet d'observer la moyenne de la distribution (point rouge) qui est égal à $0.5$. L'équation \ref{EQ:esp beta} permet de confirmer cette valeur. 
\begin{align*}
\theta \sim \text{Beta}(\alpha = 2, \beta = 2)  \\
E[\theta] = \frac{\alpha}{\alpha + \beta} = 0.5 \tag{3.1}
\label{EQ:esp beta}
\end{align*}
```{r figs,echo = FALSE, fig.width=4, fig.height=3, fig.align="center"}
ggplot(data.frame(x=c(0, 1)),aes(x)) +
    stat_function(fun=dbeta, args = list(2,2))+
    #ggtitle(expression(paste("Densité d'un loi beta(", alpha,"= 2,",beta,"= 2)")))+
    xlab(expression(theta))+
    ylab("Densité")+
    geom_point(aes(x=0.5, y=1.5), colour="red")
    #geom_vline(xintercept = 0.5, color = "blue")
```
\begin{center}
    Figure 3 : Densité d'une loi beta$(\alpha = 2, \beta = 2)$
\end{center}

### c) Détermination de la loi à posteriori ainsi que la valeur exacte de l’estimateur de Bayes 
On détermine la loi à posteriori, pour ensuite trouver l'estimateur de Bayes pour notre $\theta$. Puisque notre loi a priori est une Beta, la loi à posteriori devrait elle aussi suivre une Beta avec $\alpha'$ et $\beta'$.
\begin{align*}
f(\theta|x_1,...,x_n) &= \frac{f(\theta) \cdot f(x_1,...,x_n|\theta)}{\int f(\theta) \cdot f(x_1,...,x_n|\theta) d\theta} \\
&= c(x) \cdot \theta^{\alpha-1}(1-\theta)^{\beta-1} \theta^r (1 - \theta)^{x_1}...\: \theta^r (1 - \theta)^{x_n}\\
&= c(x) \cdot \theta^{\alpha + nr - 1}(1-\theta)^{\beta +\left( \sum\limits_{i=1}^n x_i \right) - 1} \\
&\sim \text{Beta}(\alpha' = \alpha + nr, \beta' = \beta + \sum_{i=1}^n x_i) \tag{3.2}
\label{EQ:posteriorie}
\end{align*}
où c(x) est une constante faisant en sorte que la densité intégrée sur tout son domaine égale à 1. Ensuite, on peut trouver l'estimateur de Bayes pour notre $\theta$, et ce, en utilisant notre unique donnée $x = 5$.
\begin{align*}
\hat{\theta}_{B} &= \int_0^1 \theta f(\theta|x) d\theta  \\
&= \frac{\alpha'}{\alpha' + \beta'} \\
&= \frac{\alpha + nr}{\alpha + nr + \beta + \sum_{i=1}^n x_i} \\
&= \frac{\alpha}{\alpha+nr+\beta+\sum_{i=1}^n x_i} + \frac{rn}{\alpha+nr+\beta+\sum_{i=1}^n x_i}  \tag{3.3} \label{EQ:bayes}\\
&= \frac{2 + (1)2}{2 + (1)2 + 2 + 5} \\
&= \frac{4}{11}
\end{align*}
L'estimateur de Bayes estime une probabilité plus grande pour notre $\theta$ que l'estimateur de vraisemblance. Puisque nous avons une seule donnée, l'estimateur du maximum de vraisemblance possède une plus grande variance que l'estimateur de Bayes. Par contre, Bayes détermine un estimateur biaisé. En utilisant la représentation en \ref{EQ:bayes} et 
en prenant $n \rightarrow \infty$, il est possible de montrer que l'estimateur de Bayes tend vers l'estimateur du maximum de vraisemblance. On en déduit donc que l'estimateur de Bayes est préférable pour un petit échantillon de données, alors que celui du maximum de vraisemblance sera plus précis pour un grand échantillon.
\begin{align*}
\lim_{n \to \infty} \hat{\theta}_B &=
\frac{\alpha}{\alpha+nr+\beta+\sum_{i=1}^n x_i} + \frac{rn}{\alpha+nr+\beta+\sum_{i=1}^n x_i} \\
&= \lim_{n \to \infty} \frac{\alpha}{\alpha+nr+\beta+\sum_{i=1}^n x_i} + \lim_{n \to \infty} \frac{rn}{n(\frac{\alpha}{n}+r+\frac{\beta}{n}+\bar{x})} \\
&= 0 + \lim_{n \to \infty} \frac{r}{\frac{\alpha}{n}+r+\frac{\beta}{n}+\bar{x}} \\
&= \frac{r}{r+\bar{x}} = \hat{\theta}_{MLE}
\end{align*}



### d) Approximation de l'estimateur de Bayes par simulation
```{r, echo = FALSE, eval = TRUE, results = 'asis', message = FALSE, warning = FALSE}
set.seed(4545)
nsim <- 500000
simul_posterorie <- rbeta(nsim, 4, 7)
simul_bayes <- mean(simul_posterorie)
```
On simule notre estimateur de Bayes pour le comparer avec la valeur théorique calculée en c). Pour ce faire on effectue $m = 500 000$ simulations de la loi à posteriori. Comme il a été démontré à l'équation \ref{EQ:posteriorie}, cette loi suit aussi une beta avec $\alpha = 4$ et $\beta = 7$. L'estimateur de Bayes simulé consiste alors à la moyenne de ces simulations. Avec cette méthode et ce nombre important de simulations, nous obtenons $\hat{\theta}_B =$ `r simul_bayes`. Le résultat obtenu est différent seulement à partir de la $5^e$ décimal, ce qui est très précis. Pour plus de précision, il aurait été possible d'augmenter le nombre de simulations, mais cela aurait requis plus de temps et potentiellement plus de puissance machine pour une énorme quantité de simulations.



\newpage
# Annexe
# Question 1
### a) Estimation des paramètres 
```{R, echo = TRUE, eval = FALSE}
# Données utilisées afin de compléter le numéro 1 

data <-  c(1500, 6000, 3500, 3800, 1800, 5500, 4800, 4200, 3900, 3000)
```
\vspace{1\baselineskip}
```{R, echo = FALSE, eval = TRUE}
data 
```
\vspace{1\baselineskip}
```{R eval=FALSE}
# Code SAS permettant d'estimer les paramètres de la loi log-normale 
# par la méthode du maximum de vraisemblance

data MLE;
input t cens;
datalines;
1500 1
6000 1
3500 1
3800 1
1800 1
5500 1
4800 1
4200 1
3900 1
3000 1
;
run;

proc lifereg data=MLE;
	Model t*cens(0)= /covb dist=lnormal;
run;
```

### b) Détermination des primes stop-loss
```{R, echo = TRUE, eval = FALSE, results = 'asis', message = FALSE, warning = FALSE}
# Les estimateurs ont été calculés à l'aide de SAS en a)
mu <- 8.1618
sigma <-  0.4278

# Valeurs des déductibles d à utiliser
d <- 100 * seq(20,30)

# Calculer les primes STOP-LOSS pour les différents déductibles d
STOP_LOSS <- function(x) {
    exp(mu + sigma^2/2) * (1 - pnorm((log(x) - mu - sigma^2)/sigma)) - 
        x * (1 - pnorm((log(x) - mu)/sigma))
}

Primes_STOP_LOSS <- data.frame(d, "Prime" = sapply(d, function(x) STOP_LOSS(x)))

# Présenter les valeurs des primes STOP-LOSS en fonction de d 
library(xtable)
options(xtable.comment = FALSE)
xtable(Primes_STOP_LOSS, caption = "Valeurs de la prime stop-loss pour 
                 chacun des déductibles d donnés",  
                 align = c("c", "c", "c"),
                 digits = c(0, 0, 4)) 

# Représenter graphiquement l'évolution de la prime stop-loss en fonction de d
library(ggplot2)
plot1 <- ggplot(data = Primes_STOP_LOSS, aes(x= Primes_STOP_LOSS$d,
                                             y = Primes_STOP_LOSS$Prime)) 
    + geom_point() + geom_line() + xlab("d") + ylab("Prime stop-loss") 
    + ggtitle("(A)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

value_test <- data.frame(d=(100 * seq(20,60)), "Prime" = sapply((100 * seq(20,60)), 
                function(x) STOP_LOSS(x)))

plot2 <- ggplot(data=value_test, aes(x=value_test$d, y=value_test$Prime)) 
    + geom_point() + geom_line() + xlab("d") + ylab("Prime stop-loss") 
    + ggtitle("(B)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))
```

### c) Détermination des primes limited loss
```{R, echo = TRUE, eval = FALSE, results = 'asis', message = FALSE, warning = FALSE}
# Valeurs des limites u à utiliser
u <- 100 * seq(30,40)

# Calculer l'espérance limitée pour les différentes limites u
Esp_limite <- function(x) {
    exp(mu + sigma^2/2) * pnorm((log(x) - mu - sigma^2)/sigma) + 
        x * (1 - pnorm((log(x) - mu)/sigma))
}

Primes_Esp_limite <- data.frame(u, "Prime" = sapply(u, function(x) Esp_limite(x)))

# Présenter les valeurs des espérances limitées en fonction de u
library(xtable)
options(xtable.comment = FALSE)
xtable(Primes_Esp_limite, caption = "Valeurs de l'espérance limitée pour 
                 chacune des limites u données",  
                 align = c("c", "c", "c"),
                 digits = c(0, 0, 4)) 

# Représenter graphiquement l'évolution de l'espérance limitée en fonction de u
library(ggplot2)
plot3 <- ggplot(data = Primes_Esp_limite, aes(x= Primes_Esp_limite$u, 
                                              y = Primes_Esp_limite$Prime)) 
    + geom_point() + geom_line() + xlab("u") + ylab("Espérance limitée") +ggtitle("(C)") 
    + theme(plot.title =  element_text(face="bold", hjust = 0.5))

value_test_2 <- data.frame(u=(100 * seq(30,60)), "Prime" = sapply((100 * seq(30,60)), 
                    function(x) Esp_limite(x)))

plot4 <- ggplot(data=value_test_2, aes(x=value_test_2$u, y=value_test_2$Prime)) 
    + geom_point() + geom_line() + xlab("u") + ylab(" Espérance limitée") 
    + ggtitle("(D)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

# Mettre les 4 graphiques ensembles
library(gridExtra)
grid.arrange(plot1, plot2, plot3, plot4, ncol=2, nrow=2)
```

### d) Détermination de la prime stop-loss par simulation avec un déductible d = 2000
```{R, echo = TRUE, eval = FALSE, results = 'asis', message = FALSE, warning = FALSE}
# Valeurs du déductible d à utiliser
d <- 2000

# Nombre de simulations
m <- c(1e5, 5e5, 1e6)

# Simuler un échantillon de m simulations de la log log-normale
# avec les paramètres estimés en a)
simul <- function(x) rlnorm(x, meanlog = mu, sdlog = sigma)
simulation <- sapply(1:3, function(i) simul(m[i]))

# Approximer la prime STOP-LOSS ayant un déductible de 2000 par simulation
approximation <- sapply(1:3, function(x)
                    mean(sapply(1:m[x], function(i) 
                        max(0, simulation[[x]][i] - 2000))))

approx <- data.frame(m, approximation)

# Trouver les écarts relatifs (par rapport à la valeur théorique)
Prime_2000 <- Primes_STOP_LOSS$Prime[1]
Approx <- approx$approximation

Ecart <- abs((Approx-Prime_2000)/Prime_2000) * 100

# Présenter les valeurs approximées de la prime STOP-LOSS ayant un déductible de 2000 
library(xtable)
options(xtable.comment = FALSE)
xtable(approx, caption = "Valeurs approximées par simulations de la prime stop-loss 
                 ayant un déductible de 2000",  
                 align = c("c", "c", "c"),
                 digits = c(0, 0, 4)) 
```


# Question 2
### a) Estimation des paramètres
```{R eval=FALSE}
# Code SAS permettant d'estimer les paramètres de la loi log-normale 
# par la méthode du maximum de vraisemblance
data donnees;
input lb ub;
datalines;
0.00001 250
0.00001 250
0.00001 250
250 500
250 500
250 500
250 500
500 750
500 750
500 750
500 750
500 750
750 1000
750 1000
750 1000
750 1000
750 1000
1000 1250
1000 1250
1000 1250
1000 1250
1250 1500
1250 1500
1250 1500
1500 2000
1500 2000
1500 2000
2000 2500
2000 2500
2000 2500
2500 3000
2500 3000
3000 5000
3000 5000
;
run;

proc lifereg data=donnees;
	Model (lb,ub)= /covb dist=lnormal;
run;
```

### b) Détermination des primes stop-loss
```{R, echo = TRUE, eval = FALSE, results = 'asis', message = FALSE, warning = FALSE}
# Les estimateurs ont été calculés à l'aide de SAS en a)
mu_2 <- 6.8418
sigma_2 <-  0.8278

# Valeurs des déductibles d à utiliser
d_2 <- 100 * seq(20,30)

# Calculer les primes STOP-LOSS pour les différents déductibles d
STOP_LOSS_2 <- function(x) {
    exp(mu_2 + sigma_2^2/2) * (1 - pnorm((log(x) - mu_2 - sigma_2^2)/sigma_2)) - 
        x * (1 - pnorm((log(x) - mu_2)/sigma_2))
}

Primes_STOP_LOSS_2 <- data.frame(d_2, "Prime" = sapply(d_2, function(x) STOP_LOSS_2(x)))

# Présenter les valeurs des primes STOP-LOSS en fonction de d 
library(xtable)
options(xtable.comment = FALSE)
xtable(Primes_STOP_LOSS_2, caption = "Valeurs de la prime STOP-LOSS pour 
                 chacun des déductibles d donnés",  
                 align = c("c", "c", "c"),
                 digits = c(0, 0, 4)) 

# Représenter graphiquement l'évolution de la prime stop-loss en fonction de d
library(ggplot2)
plot5 <- ggplot(data = Primes_STOP_LOSS_2, aes(x= Primes_STOP_LOSS_2$d_2, 
                                               y = Primes_STOP_LOSS_2$Prime)) 
    + geom_point() + geom_line() + xlab("d") + ylab("Prime stop-loss") 
    + ggtitle("(A)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

value_test_3 <- data.frame(d=(100 * seq(20,60)), "Prime" = sapply((100 * seq(20,60)), 
                    function(x) STOP_LOSS_2(x)))

plot6 <- ggplot(data=value_test_3, aes(x=value_test_3$d, y=value_test_3$Prime)) 
    + geom_point() + geom_line() + xlab("d") + ylab("Prime stop-loss") +ggtitle("(B)") 
    + theme(plot.title =  element_text(face="bold", hjust = 0.5))
```

### c) Détermination des primes limited loss
```{R, echo = TRUE, eval = FALSE, results = 'asis', message = FALSE, warning = FALSE}
# Valeurs des limites u à utiliser
u_2 <- 100 * seq(30,40)

# Calculer l'espérance limitée pour les différents limites u
Esp_limite_2 <- function(x) {
    exp(mu_2 + sigma_2^2/2) * pnorm((log(x) - mu_2 - sigma_2^2)/sigma_2) + 
        x * (1 - pnorm((log(x) - mu_2)/sigma_2))
}

Primes_Esp_limite_2 <- data.frame(u_2, "Prime" = sapply(u_2, function(x) Esp_limite_2(x)))

# Présenter les valeurs des espérances limitées en fonction de u
library(xtable)
options(xtable.comment = FALSE)
xtable(Primes_Esp_limite_2, caption = "Valeurs de l'espérance limitée 
                 pour chacune des limites u données",  
                 align = c("c", "c", "c"),
                 digits = c(0, 0, 4))

# Représenter graphiquement l'évolution de l'espérance limitée en fonction de u
library(ggplot2)
plot7 <- ggplot(data = Primes_Esp_limite_2, aes(x= Primes_Esp_limite_2$u_2, 
                                                y = Primes_Esp_limite_2$Prime)) 
    + geom_point() + geom_line() + xlab("u") + ylab("Espérance limitée") 
    + ggtitle("(C)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

value_test_4 <- data.frame(u=(100 * seq(30,60)), "Prime" = sapply((100 * seq(30,60)), 
                    function(x) Esp_limite_2(x)))

plot8 <- ggplot(data=value_test_4, aes(x=value_test_4$u, y=value_test_4$Prime)) 
    + geom_point() + geom_line() + xlab("u") + ylab(" Espérance limitée") 
    + ggtitle("(D)") + theme(plot.title =  element_text(face="bold", hjust = 0.5))

# Mettre les 4 graphiques ensembles
library(gridExtra)
grid.arrange(plot5, plot6, plot7, plot8, ncol=2, nrow=2)
```


# Question 3
### a) Estimation du paramètre $\theta$
Aucun code n'a été utilisé pour cette section.

### b) Présentation graphique de la loi beta a priori
```{R, echo = TRUE, eval = FALSE, results = 'asis', message = FALSE, warning = FALSE}
# Création du graphique de la loi beta
ggplot(data.frame(x=c(0, 1)),aes(x)) +
    stat_function(fun=dbeta, args = list(2,2))+
    xlab(expression(theta))+
    ylab("Densité")+
    geom_point(aes(x=0.5, y=1.5), colour="red")
```

### c) Détermination de la loi a posteriori ainsi que la valeur exacte de l’estimateur de Bayes
Aucun code n'a été utilisé pour cette section.

### d) Approximation de l'estimateur de Bayes par simulation
```{R, echo = TRUE, eval = FALSE, results = 'asis', message = FALSE, warning = FALSE}
# Simulation de l'estimateur de Bayes
set.seed(4545)
nsim <- 500000
simul_posterorie <- rbeta(nsim, 4, 7)
simul_bayes <- mean(simul_posterorie)
```